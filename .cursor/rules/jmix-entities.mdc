---
globs: ["**/entity/**/*.java"]
autoFix: true
version: "1.1.0"
---

# JMIX ENTITIES

## ENTITY ANNOTATIONS (Basic)
@JmixEntity @Entity @Table(name="MY_ENTITY") | @Id @JmixGeneratedValue @Column(name="ID") UUID id | @Version @Column(name="VERSION", nullable=false) Integer version | @Column(name="FIELD_NAME", nullable=false, length=100) | @Transient for non-persisted

## ENTITY ANNOTATIONS (Jmix-specific)
**@JmixGeneratedValue**: UUID generation | `sequenceName` - Explicit sequence (auto-created) | `sequenceCache` - Enable caching (only with sequenceName) | **@JmixId**: ID for DTO entities | **@JmixProperty**: Mark field/method as attribute (`mandatory=true` if needed) | **@PropertyDatatype**: Specify Datatype by ID | **@NumberFormat**: Format Number (pattern, separators) | **@Store**: Link to additional data store | **@PostConstruct**: Initialize instance (accepts Spring beans) | **@Secret**: Mark sensitive fields (auto-hides in UI/logs)

## ENTITY METADATA
**@InstanceName**: Display name method (UI, lookups) | **@DependsOnProperties**: Instance name dependencies | **@Composition**: Composition relationship (cascade delete) | **@OnDelete**: Delete policy (CASCADE, DENY, UNLINK) | **@OnDeleteInverse**: Delete policy when referenced deleted

**Metadata API**: Use `Metadata` bean to access programmatically

## DELETE POLICIES
**@OnDelete**: When THIS entity deleted:
- `DeletePolicy.DENY`: Throw exception if reference not null
- `DeletePolicy.CASCADE`: Delete referenced
- `DeletePolicy.UNLINK`: Set reference to null (owning side only, with @JoinColumn)

**@OnDeleteInverse**: When referenced deleted:
- `DeletePolicy.DENY`: Throw exception
- `DeletePolicy.CASCADE`: Delete this
- `DeletePolicy.UNLINK`: Set reference to null (owning side only)

**Note**: For soft-deleted, handled at runtime. For hard-deleted, @OnDeleteInverse handled by Liquibase (CASCADE/UNLINK only, owning side only).

## DATA STORES
**Main Store**: Default, configured via `main.datasource.*`

**Additional Stores**: Multiple databases:
- Add to `jmix.core.additional-stores = locations,inmem`
- Configure via `{storeName}.datasource.*`
- Use `@Store(name = "locations")` on entity
- Studio auto-generates `{Store}StoreConfiguration`

**Custom Stores** (Non-JPA): Implement `DataStore` (prototype) + `StoreDescriptor` (singleton) | Add to `jmix.core.additional-stores` | Configure `jmix.core.store-descriptor_{storeName}` | Use `@Store(name = "inmem")`

## SOFT DELETION
**@DeletedDate**: Deletion timestamp | **@DeletedBy**: Deletion user | Auto-set on `dataManager.remove()` | Excluded from queries by default

**Querying**: Use `dataManager.load().condition(PropertyCondition.isSet("deletedDate"))` or `UnconstrainedDataManager` for system operations

## ENUMERATIONS
**@Enumerated(EnumType.STRING)**: Store as string (preferred) | **@Enumerated(EnumType.ORDINAL)**: Store as integer (not recommended)

## DATATYPE
**@PropertyDatatype**: Specify custom Datatype by ID | **Custom**: Implement `io.jmix.core.metamodel.datatype.Datatype<T>` and register as Spring bean | Used for UI formatting, validation, conversion

## BEAN VALIDATION
**Layers**: UI (Binder) → Service (business) → Entity (Bean Validation) | **Annotations**: @NotNull, @Size, @Email, @Min, @Max, @Pattern, @Past, @Future | **Groups**: Use for conditional validation (create vs update)

## DATABASE MIGRATIONS (Liquibase)
**Changelog**: `V{version}__{description}.xml` or `{timestamp}__{description}.xml` | **Main**: `main.liquibase.change-log` | **Additional**: `{storeName}.liquibase.change-log`

**Rules**: ✅ NEVER modify applied changelogs | ✅ Use incremental changesets | ✅ Naming: UPPER_SNAKE_CASE (USER_ not USER) | ✅ Always specify indexes on foreign keys | ✅ Use explicit @JoinColumn names | ✅ @Version for optimistic locking

**Studio**: Use Studio designer - auto-generates Liquibase changelogs
