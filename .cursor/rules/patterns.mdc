---
globs: ["**/service/**/*.java", "**/view/**/*.java", "**/rest/**/*.java", "**/entity/**/*.java", "**/repository/**/*.java", "**/exception/**/*.java", "**/controller/**/*.java", "**/dto/**/*.java", "**/api/**/*.java", "**/async/**/*.java", "**/*Async*.java", "**/*Task*.java"]
version: "3.0.0"
---

# PATTERNS & ARCHITECTURE

## ERROR HANDLING
**Principles**: Fail fast: Validate early, throw specific exceptions | No swallowing: Always log or rethrow | User-friendly: Map technical errors to UI messages | Specific exceptions: Avoid generic Exception | **Exception Hierarchy**: Jmix Built-in: `EntityAccessException` (security violation) | `OptimisticLockException` (concurrent modification) | `ConstraintViolationException` (validation failed) | `NoResultException` (entity not found, use `.optional()`) | Custom Exceptions: Extend RuntimeException for business exceptions | **Patterns**: Service Layer: @Transactional: Rollback on RuntimeException (default) | Checked: Explicit rollback `@Transactional(rollbackFor = Exception.class)` | Validation: Throw `IllegalArgumentException` for invalid input | View Layer: OptimisticLock: Reload entity, notify user, allow retry | Validation: Show field-level errors | Security: Redirect to error page | REST Controllers: @ExceptionHandler: Map to HTTP status codes | 400: Validation errors | 404: Not found | 409: Conflict (optimistic lock) | 500: Internal error (log, don't expose) | **Antipatterns**: ❌ `catch (Exception e) { }` (silent swallowing) | ❌ `e.printStackTrace()` → use `log.error()` | ❌ Generic `RuntimeException` → specific type | ❌ Exposing stack trace to user | ❌ Returning null instead of Optional/throwing | **Logging**: `log.error("Operation failed: entity={}, error={}", entityId, e.getMessage(), e)` | Always include context | Include stack trace for unexpected errors

## ASYNC PATTERNS (Java 21)
**Virtual Threads**: Java 21: Prefer virtual threads over platform threads | Spring Boot 3.2+: `spring.threads.virtual.enabled=true` | Tomcat: Auto-uses virtual threads for requests | Usage: Simple task: `Thread.startVirtualThread(() -> processTask())` | ExecutorService: `try (var executor = Executors.newVirtualThreadPerTaskExecutor()) { executor.submit(() -> processTask()); }` | When to Use: ✅ I/O-bound operations (DB, HTTP, file) | ✅ High-concurrency scenarios | ❌ CPU-bound tasks (use platform threads) | ❌ Long-running tasks with thread-locals | **CompletableFuture**: Async composition: Chain operations | Error handling: `exceptionally()`, `handle()` | Combine: `thenCombine()`, `allOf()`, `anyOf()` | Patterns: `CompletableFuture.supplyAsync(() -> fetchData()).thenApply(data -> transform(data)).exceptionally(ex -> handleError(ex))` | **Spring @Async**: Setup: `@EnableAsync` + `@Async` on method | Return: `void`, `Future<T>`, `CompletableFuture<T>` | Executor: Configure `TaskExecutor` bean | Jmix Integration: ⚠️ Security context: Not propagated by default | ⚠️ DataManager: Use `UnconstrainedDataManager` in async or propagate context | ✅ Events: Use `@TransactionalEventListener(phase = AFTER_COMMIT)` | **Antipatterns & Testing**: Antipatterns: ❌ `Thread.sleep()` in virtual threads → use `TimeUnit.sleep()` | ❌ Blocking in `CompletableFuture.supplyAsync()` without executor | ❌ `synchronized` with virtual threads (pins carrier) → use `ReentrantLock` | ❌ Missing error handling in async chains | Testing: Use `Awaitility.await().atMost(5, SECONDS).until(() -> condition)` | Mock async calls with `CompletableFuture.completedFuture()`

## API DESIGN
**REST Conventions**: Methods: GET (read), POST (create), PUT (full update), PATCH (partial), DELETE (remove) | URLs: `/api/v1/entities`, `/api/v1/entities/{id}` | Plural nouns: `/users` not `/user` | Nested: `/orders/{id}/items` | **HTTP Status Codes**: 2xx: 200 OK, 201 Created, 204 No Content | 4xx: 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 409 Conflict, 422 Unprocessable | 5xx: 500 Internal Error | **DTO Patterns**: Rule: ❌ Never expose entities directly | ✅ Use DTOs for API responses | Types: `CreateDto` (input for POST, no ID) | `UpdateDto` (input for PUT/PATCH) | `ResponseDto` (output, read-only) | `ListDto` (paginated list wrapper) | Mapping: Use MapStruct or manual mapping in service layer | **Pagination & Filtering**: Pagination: `?page=0&size=20&sort=name,asc` | Filtering: `?status=ACTIVE&createdAfter=2024-01-01` | Response: `{ content: [], page: 0, size: 20, totalElements: 100, totalPages: 5 }` | **Error Responses & Jmix REST API**: Error Responses (RFC 7807): Use standard format with type, title, status, detail, instance | Jmix REST API: Generic REST: Auto-generated CRUD for entities | Custom: `@RestController` + `@RequestMapping` | Security: `@PreAuthorize`, resource roles | OpenAPI: Auto-generated via `jmix-rest-openapi` | **Versioning & Antipatterns**: Versioning: URL: `/api/v1/`, `/api/v2/` (preferred) | Header: `Accept: application/vnd.api.v1+json` | Query: `?version=1` (not recommended) | Antipatterns: ❌ Exposing entities → DTOs | ❌ Business logic in controllers → services | ❌ Generic `/api/getData` → RESTful URLs | ❌ Ignoring HTTP methods → use correctly | ❌ 200 for errors → proper status codes

## REFACTORING PATTERNS
**When to Refactor**: Triggers (Code Smells): Long Method: >20 lines → Extract Method | Large Class: >250 lines → Extract Class | Long Parameter List: >3 params → Parameter Object/Builder | Duplicate Code: 3+ occurrences → Extract Method/Class | Feature Envy: Method uses other class more → Move Method | Data Clumps: Same fields together → Extract Class | Metrics Triggers: Cyclomatic complexity >10 → Split method | Cognitive complexity >10 → Simplify logic | Deep nesting >3 levels → Early return, Extract Method | When NOT to Refactor: ❌ Working code without tests | ❌ Before deadline without buffer | ❌ "Just in case" without smell | ❌ During incident response | **Safe Refactoring Checklist**: 1) ✅ Tests pass before refactoring | 2) ✅ Small incremental changes | 3) ✅ Run tests after each change | 4) ✅ Commit frequently | 5) ✅ Review diff before push | **Common Refactorings**: Extract Method: Before: Long method with commented sections | After: Small methods with descriptive names | IDE: Ctrl+Alt+M (IntelliJ) | Extract Class: Before: Class with multiple responsibilities | After: Focused classes, single responsibility | Pattern: Move related fields + methods together | Replace Conditional with Polymorphism: Before: Switch/if-else on type | After: Interface + implementations | When: >3 branches, type-based logic | Introduce Parameter Object: Before: `method(a, b, c, d, e)` | After: `method(Config config)` | When: >3 related parameters | **Jmix-Specific**: View Refactoring: Extract complex UI logic to separate `*Helper` class | Move business logic from View to Service | Extract reusable components | Entity Refactoring: ⚠️ Requires Liquibase migration for DB changes | Use Studio refactoring tools | Test with existing data | Service Refactoring: Split by domain (UserService, OrderService) | Extract common logic to base/utility classes

## PERFORMANCE
**Query Optimization**: N+1 Problem: Symptom: Many queries for related entities | Solution: FetchPlan with relationships | Query Performance: ✅ Index foreign keys and frequently filtered columns | ✅ Use `LIMIT` / `.maxResults()` for large datasets | ✅ Prefer `EXISTS` over `COUNT` for existence checks | ✅ Use query cache for read-heavy, rarely-changed data | ❌ `SELECT *` → select only needed fields | **Jmix Caching**: Entity Cache: Config: `jmix.core.entity-cache.enabled=true` | Use: Read-heavy entities | Query Cache: `dataManager.load(Entity.class).query("...").cacheable(true).list()` | Use: Frequently executed, rarely changed queries | Invalidation: Automatic on save/delete | Manual: `entityCache.evict(Entity.class, id)` | **View Performance**: Lazy Loading: `grid.setItems(query -> service.find(PageRequest.of(query.getPage(), query.getPageSize())))` | Virtual Scrolling: `grid.setPageSize(50)` (loads only visible + buffer) | Avoid: ❌ `grid.setItems(dataManager.load().all().list())` (loads all) | ❌ Heavy operations in UI thread | **Memory & Monitoring**: Large Collections: ✅ Pagination (DataGrid, REST) | ✅ Streaming for export (`Stream<Entity>`) | ✅ Batch processing (`saveAll`, `removeAll`) | ❌ Loading all entities to memory | Connection Pooling: HikariCP default | Monitor: `jmix.data.hikari.*` metrics | Logging: `logging.level.org.eclipse.persistence.logging.sql: DEBUG` | Metrics: Micrometer + Prometheus/Grafana | JMX for JVM metrics | `jmix-micrometer` for Jmix-specific | Profiling: IntelliJ Profiler (CPU, Memory) | VisualVM for heap analysis | JFR (Java Flight Recorder) for production | **Caching Strategy**: Stack: @UIScope/@SessionScope | Spring Events | TTL | ConcurrentHashMap | UI.access() | Rules: Scope: @UIScope (tab) | @SessionScope (shared) | Config: @Value defaults | Invalidation: @EventListener + TTL 1-5min | Bounded: LRU eviction | Reactive UI (@Push): ✅ Cache invalidate immediately → UI debounce 300-500ms with UI.access() | ❌ Cooldown in cache → stale | beforeClientResponse() → no push | Rule: Cooldown at UI layer, NOT cache (data consistency > performance) | Antipatterns: Static cache → leak | TTL only → stale | Unbounded → leak | Logging in get() → overhead | beforeClientResponse() → no push | Cooldown >500ms → poor UX | Cooldown in cache → data inconsistency | **Quick Checklist**: ✅ FetchPlan for relationships | ✅ Indexes on FKs | ✅ Pagination for lists | ✅ Query cache for hot data | ✅ Lazy loading in grids | ✅ Caching strategy | ❌ N+1 queries | ❌ Load all to memory | ❌ Heavy ops in UI

## OBSERVABILITY & MONITORING
**Metrics (Micrometer)**: ✅ Use `@Timed` for method execution time | ✅ Use `@Counted` for business event counters | ✅ Custom metrics: `MeterRegistry.counter("business.event", "tag", "value")` | ✅ Export: Prometheus (`management.metrics.export.prometheus.enabled=true`) | ✅ Jmix metrics: `jmix-micrometer` for DataManager operations | ✅ JVM metrics: Auto-exposed via Spring Actuator | **Distributed Tracing (OpenTelemetry)**: ✅ Auto-instrumentation via Spring Boot (`spring-boot-starter-actuator`) | ✅ Custom spans: `@WithSpan` or `Tracer` bean | ✅ Trace context: Auto-propagated via MDC (`requestId`, `traceId`) | ✅ Export: OTLP endpoint (`management.otlp.logging.endpoint`) | ✅ Correlation: Use `requestId` (UUID) in logs and traces | **Health Checks**: ✅ Spring Actuator: `/actuator/health` | ✅ Custom health indicators: Implement `HealthIndicator` | ✅ Readiness: `/actuator/health/readiness` (for K8s) | ✅ Liveness: `/actuator/health/liveness` (for K8s) | ✅ Database health: Auto-checked via `DataSourceHealthIndicator` | **Best Practices**: ✅ Log structured (JSON in production via Logback) | ✅ Metrics for business events (user actions, entity CRUD) | ✅ Traces for distributed requests (REST, async operations) | ✅ Health checks for K8s probes (readiness/liveness) | ✅ Correlation IDs: `requestId` in MDC, logs, traces | ✅ Alerting: Configure Prometheus alerts for critical metrics | **Antipatterns**: ❌ Logging sensitive data (passwords, tokens, PII) | ❌ High-cardinality metrics (unique values per request) | ❌ Missing correlation IDs (hard to trace requests) | ❌ No health checks (K8s can't detect failures)

## SCALABILITY
**Horizontal Scaling**: ✅ Stateless services (no session state in memory) | ✅ External session store (Redis) if needed | ✅ Connection pooling: HikariCP (tune `maximumPoolSize` based on load) | ✅ Database connection limits: Monitor and scale accordingly | ✅ Load balancing: Stateless design enables horizontal scaling | **Distributed Caching**: ✅ Redis: Use `@Cacheable` with Redis cache manager | ✅ Hazelcast: For in-memory distributed cache | ✅ Cache invalidation: Use Spring Events for multi-instance coordination | ✅ Cache patterns: Cache-Aside (read-through), Write-Through, Write-Behind | ✅ TTL: Set appropriate expiration for cache entries | **Load Balancing**: ✅ Stateless application design (no sticky sessions) | ✅ Health checks: For load balancer routing (readiness probe) | ✅ Session affinity: Avoid (use external session store if needed) | ✅ Graceful shutdown: Handle in-flight requests during deployment | **Best Practices**: ✅ Monitor connection pool usage | ✅ Scale database connections with application instances | ✅ Use distributed cache for shared state | ✅ Implement circuit breakers for external dependencies | ✅ Rate limiting: Prevent abuse (Spring Security rate limiting) | **Antipatterns**: ❌ In-memory session state (breaks horizontal scaling) | ❌ Sticky sessions (prevents load balancing) | ❌ Unbounded connection pools (exhausts database) | ❌ No health checks (load balancer can't route properly)
