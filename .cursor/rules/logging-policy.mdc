---
globs: ["**/*.java"]
autoFix: false
version: "1.0.0"
---

# LOGGING POLICY

## PRINCIPLES

**Observability First**: Logs are the eyes of the system. Removing logs = loss of observability.

**Structured Logging**: Always use parameterized messages, never concatenation.

**Context Matters**: Always log important context (userId, entityId, operation, requestId).

**Security**: Never log passwords, tokens, secrets, PII (except audit.log with masking).

## LOG LEVELS

### DEBUG
**When to use**:
- Detailed diagnostics (config loading, validation, internal states)
- Method execution tracing
- Call parameters (safe data)
- Internal component states

**Examples**:
```java
log.debug("Loading configuration from .env file");
log.debug("User entity initialized: isNew={}, username={}", isNew, username);
log.debug("Password validation passed: username={}", username);
```

**Important**: DEBUG logs do NOT affect production (INFO level), but are critical for diagnostics.

### INFO
**When to use**:
- Business events (entity creation/update, successful operations)
- Component start/stop
- Important state changes
- Successful user operations

**Examples**:
```java
log.info("User created successfully: id={}, username={}", user.getId(), user.getUsername());
log.info("User '{}' successfully logged in", username);
log.info("Application started successfully");
log.info("Loaded {} environment variables from .env file", count);
```

### WARN
**When to use**:
- Issues that don't break functionality
- Validation failed (expected behavior)
- Retry operations
- Deprecated API usage
- Suboptimal but working scenarios

**Examples**:
```java
log.warn("Password validation failed: {}", validationError);
log.warn("Login failed for user '{}': {}", username, reason);
log.warn("Cache '{}' is not recording statistics", cacheName);
```

### ERROR
**When to use**:
- Critical errors, exceptions
- Operations that cannot be executed
- System errors
- Unexpected exceptions

**Examples**:
```java
log.error("Failed to save user: id={}, username={}", user.getId(), user.getUsername(), exception);
log.error("Database connection failed", exception);
```

## STRUCTURED LOGGING

### ✅ Correct
```java
log.info("User created: id={}, username={}", user.getId(), user.getUsername());
log.debug("Processing request: method={}, path={}", method, path);
log.warn("Validation failed: field={}, error={}", fieldName, error);
```

### ❌ Incorrect
```java
log.info("User created: id=" + user.getId() + ", username=" + user.getUsername()); // Concatenation
log.info("User created: " + user); // toString() in string
log.info("User created"); // No context
```

## WHEN NOT TO REMOVE LOGS

**CRITICAL**: Do NOT remove logs in the following cases:

1. **Configuration and initialization**:
   - Config loading (.env, properties)
   - Component initialization
   - Application start/stop
   - Database migrations

2. **Error handling**:
   - Catch blocks (always log exceptions)
   - Validation failed
   - Retry operations

3. **Business events**:
   - Entity creation/update/deletion
   - Authentication (successful and failed)
   - Critical operations

4. **Diagnostics**:
   - DEBUG logs for internal states
   - Execution tracing
   - Call parameters

**Rule**: If logging helps understand what's happening in the system - do NOT remove it.

## SECURITY

### ❌ Never log
- Passwords (plain text or hashed)
- Tokens (JWT, API keys, session tokens)
- Secrets (private keys, credentials)
- PII without masking (except audit.log)
- SQL with parameters containing secrets

### ✅ Safe logging
```java
// ✅ Correct
log.info("User authenticated: username={}", username);
log.debug("Password validation passed: username={}", username);

// ❌ Incorrect
log.info("User authenticated: password={}", password); // NEVER!
log.debug("Token: {}", token); // NEVER!
```

## CONTEXT (MDC)

**Always use MDC for request context**:
- `requestId` - unique request ID (UUID)
- `userId` - user ID (if authenticated)
- `sessionId` - session ID (optional)

**Example**:
```java
MDC.put("requestId", UUID.randomUUID().toString());
MDC.put("userId", getCurrentUserId());
try {
    // ... operation
} finally {
    MDC.clear();
}
```

## AUDIT LOGGING

**Use separate logger `com.digtp.start.audit`** for business events:
- Entity creation/update/deletion
- Authentication (successful and failed)
- Critical operations
- Security changes

**Example**:
```java
@Slf4j
public class AuditService {
    private static final Logger auditLogger = LoggerFactory.getLogger("com.digtp.start.audit");
    
    public void logUserCreated(UUID userId, String username) {
        auditLogger.info("USER_CREATED: userId={}, username={}", userId, username);
    }
}
```

## PERFORMANCE

### Performance logging
- Log slow operations (>100ms for services, >500ms for views)
- Use DEBUG level for detailed tracing
- Don't log in hot paths unnecessarily

**Example**:
```java
long start = System.currentTimeMillis();
try {
    // ... operation
} finally {
    long duration = System.currentTimeMillis() - start;
    if (duration > 100) {
        log.debug("Slow operation: method={}, duration={}ms", methodName, duration);
    }
}
```

## ANTIPATTERNS

### ❌ Removing logs for "code cleanliness"
```java
// ❌ BAD - loss of observability
if (dotenvProperties.isEmpty()) {
    // No variables to load
    return;
}

// ✅ GOOD - preserve observability
if (dotenvProperties.isEmpty()) {
    log.debug("No .env file found or all variables already set");
    return;
}
```

### ❌ Logging without context
```java
// ❌ BAD
log.info("User created");

// ✅ GOOD
log.info("User created: id={}, username={}", user.getId(), user.getUsername());
```

### ❌ Logging in loop without level check
```java
// ❌ BAD - creates strings even if DEBUG is disabled
for (User user : users) {
    log.debug("Processing user: " + user.getUsername());
}

// ✅ GOOD - parameterized logging
for (User user : users) {
    log.debug("Processing user: username={}", user.getUsername());
}
```

## EXAMPLES BY SCENARIO

### Configuration
```java
// ✅ DEBUG for details
log.debug("Loaded {} from .env file", key);
log.debug("No .env file found or error loading it: {}", exception.getMessage(), exception);

// ✅ INFO for result
log.info("Loaded {} environment variables from .env file", count);
```

### Business operations
```java
// ✅ INFO for successful operations
log.info("User created successfully: id={}, username={}", user.getId(), user.getUsername());
log.info("User '{}' successfully logged in", username);

// ✅ WARN for validation problems
log.warn("Password validation failed: {}", validationError);
log.warn("Login failed for user '{}': {}", username, reason);
```

### Errors
```java
// ✅ ERROR with exception
log.error("Failed to save user: id={}, username={}", user.getId(), user.getUsername(), exception);

// ✅ WARN for expected problems
log.warn("Password confirmation validation failed");
```

## CHECKLIST

Before removing or changing a log, ask yourself:

- [ ] Does this log help understand what's happening in the system?
- [ ] Is it used for diagnosing problems?
- [ ] Does it contain important context (userId, entityId, operation)?
- [ ] Is this a business event or error?

**If at least one answer is "yes" - do NOT remove the log.**

## SUMMARY

1. **Observability First** - logs are critical for understanding the system
2. **Structured Logging** - always parameterized messages
3. **Context Matters** - always log important context
4. **Security** - never log secrets
5. **Don't Remove Logs** - if a log helps understand the system, keep it
6. **Use Right Level** - DEBUG/INFO/WARN/ERROR as appropriate
7. **MDC for Tracing** - use MDC for request tracing
8. **Audit for Business** - use audit.log for business events
