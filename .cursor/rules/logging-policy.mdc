---
globs: ["src/main/**/*.java", "src/test/**/*.java"]
autoFix: false
version: "2.0.0"
---

# LOGGING POLICY

## PRINCIPLES
**Observability First**: Logs are the eyes of the system. Removing logs = loss of observability.
**Structured Logging**: Always use parameterized messages, never concatenation.
**Context Matters**: Always log important context (userId, entityId, operation, requestId).
**Security**: Never log passwords, tokens, secrets, PII (except audit.log with masking).

## LOG LEVELS

**DEBUG**: Detailed diagnostics, method tracing, internal states. Does NOT affect production (INFO level).
```java
log.debug("Loading configuration from .env file");
log.debug("User entity initialized: isNew={}, username={}", isNew, username);
```

**INFO**: Business events (entity CRUD, successful operations), component start/stop, state changes.
```java
log.info("User created successfully: id={}, username={}", user.getId(), user.getUsername());
log.info("Application started successfully");
```

**WARN**: Issues that don't break functionality, validation failed (expected), retry operations, deprecated API.
```java
log.warn("Password validation failed: {}", validationError);
log.warn("Login failed for user '{}': {}", username, reason);
```

**ERROR**: Critical errors, exceptions, operations that cannot be executed, system errors.
```java
log.error("Failed to save user: id={}, username={}", user.getId(), user.getUsername(), exception);
```

## STRUCTURED LOGGING

✅ **Correct**: `log.info("User created: id={}, username={}", user.getId(), user.getUsername());`
❌ **Incorrect**: `log.info("User created: id=" + user.getId());` // Concatenation
❌ **Incorrect**: `log.info("User created");` // No context

## WHEN NOT TO REMOVE LOGS

**CRITICAL**: Do NOT remove logs for:
1. **Configuration/initialization**: Config loading, component init, app start/stop, DB migrations
2. **Error handling**: Catch blocks (always log exceptions), validation failed, retry operations
3. **Business events**: Entity CRUD, authentication (success/failure), critical operations
4. **Diagnostics**: DEBUG logs for internal states, execution tracing, call parameters

**Rule**: If logging helps understand what's happening - do NOT remove it.

## SECURITY

❌ **Never log**: Passwords (plain/hashed), tokens (JWT, API keys, sessions), secrets, PII without masking (except audit.log), SQL with secret parameters.

✅ **Safe**: `log.info("User authenticated: username={}", username);`
❌ **Never**: `log.info("User authenticated: password={}", password);`

## CONTEXT (MDC)

Always use MDC for request context: `requestId` (UUID), `userId` (if authenticated), `sessionId` (optional).
```java
MDC.put("requestId", UUID.randomUUID().toString());
MDC.put("userId", getCurrentUserId());
try {
    // ... operation
} finally {
    MDC.clear();
}
```

## AUDIT LOGGING

Use separate logger `com.digtp.start.audit` for business events (entity CRUD, authentication, critical operations, security changes).
```java
private static final Logger auditLogger = LoggerFactory.getLogger("com.digtp.start.audit");
auditLogger.info("USER_CREATED: userId={}, username={}", userId, username);
```

## PERFORMANCE

Log slow operations (>100ms services, >500ms views) at DEBUG level. Don't log in hot paths unnecessarily.
```java
long duration = System.currentTimeMillis() - start;
if (duration > 100 && log.isDebugEnabled()) {
    log.debug("Slow operation: method={}, duration={}ms", methodName, duration);
}
```

## ANTIPATTERNS

❌ **Removing logs for "cleanliness"**: `if (isEmpty()) return;` → ✅ `if (isEmpty()) { log.debug("..."); return; }`
❌ **No context**: `log.info("User created");` → ✅ `log.info("User created: id={}, username={}", id, username);`
❌ **Concatenation in loop**: `log.debug("User: " + user);` → ✅ `log.debug("User: username={}", username);`

## CHECKLIST

Before removing/changing a log: Does it help understand the system? Used for diagnostics? Contains context (userId, entityId, operation)? Business event or error? **If yes → keep it.**

## ERROR LOGGING

**CRITICAL**: Always log exceptions in catch blocks with context:
```java
try {
    // operation
} catch (final Exception exception) {
    log.error("Operation failed: entityId={}, username={}, error={}", entityId, username, exception.getMessage(), exception);
    // handle error
}
```

**Best Practices**:
- ✅ Always include exception as last parameter: `log.error("...", exception)`
- ✅ Include context: entityId, userId, operation name
- ✅ Use ERROR level for unexpected exceptions
- ✅ Use WARN level for expected exceptions (validation, business rules)
- ❌ Never swallow exceptions silently
- ❌ Never use `printStackTrace()` or `System.out.println()`

## EXAMPLES

### ✅ Good: Structured logging with context
```java
log.info("User created: id={}, username={}, createdBy={}", userId, username, currentUser);
log.warn("Login failed: username={}, reason={}", username, reason, exception);
log.error("Failed to save user: id={}, username={}, error={}", userId, username, exception.getMessage(), exception);
```

### ❌ Bad: Concatenation, no context, silent failures
```java
log.info("User created: id=" + userId); // Concatenation
log.info("User created"); // No context
catch (Exception e) { } // Silent failure
```

## SUMMARY

1. Observability First | 2. Structured Logging (parameterized) | 3. Context Matters | 4. Security (no secrets) | 5. Don't Remove Logs | 6. Use Right Level (DEBUG/INFO/WARN/ERROR) | 7. MDC for Tracing | 8. Audit for Business | 9. Always Log Exceptions | 10. Include Context in Errors
