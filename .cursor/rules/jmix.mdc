---
globs: ["**/entity/**/*.java", "**/view/**/*.java", "**/service/**/*.java", "**/repository/**/*.java", "**/security/**/*.java", "**/rest/**/*.java", "**/view/**/*.xml", "**/report/**/*.java", "**/email/**/*.java", "**/bpm/**/*.java", "**/notification/**/*.java"]
version: "6.0.0"
---

# JMIX FRAMEWORK

## QUICK REFERENCE
**Data Access**: DataManager: `create()`, `save()`, `load().id().one()`, `load().condition()`, `remove()` | ❌ `new Entity()` → ✅ `dataManager.create()` | EntityManager: Only native SQL (health checks) | **Security**: @SystemLevel, @Secret, @ResourceRole, @RowLevelRole | **Views**: StandardView, StandardListView<T>, StandardDetailView<T> | @ViewComponent, @ViewController, @ViewDescriptor | DataContext, Lifecycle Events | **Entities**: @JmixEntity, @JmixGeneratedValue, @Version | @InstanceName, @Composition, @OnDelete | Liquibase migrations

## ENTITIES
**Annotations**: Basic: @JmixEntity @Entity @Table(name="MY_ENTITY") | @Id @JmixGeneratedValue @Column(name="ID") UUID id | @Version @Column(name="VERSION", nullable=false) Integer version | @Column(name="FIELD_NAME", nullable=false, length=100) | @Transient for non-persisted | Jmix-specific: @JmixGeneratedValue (UUID generation, `sequenceName` - explicit sequence auto-created, `sequenceCache` - enable caching only with sequenceName) | @JmixId (ID for DTO entities) | @JmixProperty (mark field/method as attribute, `mandatory=true` if needed) | @PropertyDatatype (specify Datatype by ID) | @NumberFormat (format Number: pattern, separators) | @Store (link to additional data store) | @PostConstruct (initialize instance, accepts Spring beans) | @Secret (mark sensitive fields, auto-hides in UI/logs) | **Metadata**: @InstanceName (display name method for UI, lookups) | @DependsOnProperties (instance name dependencies) | @Composition (composition relationship, cascade delete) | @OnDelete (delete policy: CASCADE, DENY, UNLINK) | @OnDeleteInverse (delete policy when referenced deleted) | Metadata API: Use `Metadata` bean to access programmatically | **Delete Policies**: @OnDelete (when THIS entity deleted): DeletePolicy.DENY (throw exception if reference not null) | DeletePolicy.CASCADE (delete referenced) | DeletePolicy.UNLINK (set reference to null, owning side only, with @JoinColumn) | @OnDeleteInverse (when referenced deleted): DeletePolicy.DENY (throw exception) | DeletePolicy.CASCADE (delete this) | DeletePolicy.UNLINK (set reference to null, owning side only) | Note: For soft-deleted, handled at runtime. For hard-deleted, @OnDeleteInverse handled by Liquibase (CASCADE/UNLINK only, owning side only) | **Data Stores**: Main Store: Default, configured via `main.datasource.*` | Additional Stores: Multiple databases - Add to `jmix.core.additional-stores = locations,inmem` | Configure via `{storeName}.datasource.*` | Use `@Store(name = "locations")` on entity | Studio auto-generates `{Store}StoreConfiguration` | Custom Stores (Non-JPA): Implement `DataStore` (prototype) + `StoreDescriptor` (singleton) | Add to `jmix.core.additional-stores` | Configure `jmix.core.store-descriptor_{storeName}` | Use `@Store(name = "inmem")` | **Soft Deletion**: @DeletedDate (deletion timestamp) | @DeletedBy (deletion user) | Auto-set on `dataManager.remove()` | Excluded from queries by default | Querying: Use `dataManager.load().condition(PropertyCondition.isSet("deletedDate"))` or `UnconstrainedDataManager` for system operations | **Enumerations**: @Enumerated(EnumType.STRING) (store as string, preferred) | @Enumerated(EnumType.ORDINAL) (store as integer, not recommended) | **Datatype & Validation**: @PropertyDatatype (specify custom Datatype by ID) | Custom: Implement `io.jmix.core.metamodel.datatype.Datatype<T>` and register as Spring bean | Used for UI formatting, validation, conversion | Bean Validation: Layers: UI (Binder) → Service (business) → Entity (Bean Validation) | Annotations: @NotNull, @Size, @Email, @Min, @Max, @Pattern, @Past, @Future | Groups: Use for conditional validation (create vs update) | **Database Migrations (Liquibase)**: Changelog: `V{version}__{description}.xml` or `{timestamp}__{description}.xml` | Main: `main.liquibase.change-log` | Additional: `{storeName}.liquibase.change-log` | Rules: ✅ NEVER modify applied changelogs | ✅ Use incremental changesets | ✅ Naming: UPPER_SNAKE_CASE (USER_ not USER) | ✅ Always specify indexes on foreign keys | ✅ Use explicit @JoinColumn names | ✅ @Version for optimistic locking | Studio: Use Studio designer - auto-generates Liquibase changelogs

## DATA ACCESS
**DataManager**: `create()`, `save()`, `saveAll()`, `load().id().one()`, `load().ids().list()`, `load().condition()`, `load().query()`, `load().all()`, `remove()`, `removeAll()`, `unconstrained()` | UnconstrainedDataManager: System ops, migrations, background jobs only | ⚠️ Bypasses security - use with caution | EntityManager: Only native SQL (health checks) | PropertyConditions: `equal()`, `greaterThan()`, `lessThan()`, `contains()` (LIKE), `in()`, `isNull()/isNotNull()`, `isSet()`, `and()`, `or()`, `not()` | Query Options: `.maxResults()`, `.firstResult()`, `.sort()`, `.fetchPlan()`, `.cacheable()` | **FetchPlan**: Control which entity attributes and relationships are loaded | Prevents N+1 queries | Used for eager loading of lazy relationships | Features: `add("field")`, `add("field", FetchPlan.BASE)`, `addAll()`, `addFetchPlan()`, `partial(true)` | System FetchPlans: `FetchPlan.LOCAL`, `FetchPlan.BASE`, `FetchPlan.INSTANCE_NAME` | Best Practices: Always use for @OneToMany/@ManyToMany, use partial for read-only, load nested explicitly | **Transactions**: @Transactional: Required for write operations | Optional for read-only queries | Propagation: REQUIRED (default), REQUIRES_NEW, MANDATORY, SUPPORTS, NOT_SUPPORTED, NEVER, NESTED | Isolation: READ_UNCOMMITTED, READ_COMMITTED (default), REPEATABLE_READ, SERIALIZABLE | Boundaries: ✅ Services: @Transactional | ❌ Views: NO @Transactional (use services) | ✅ REST controllers: use services | ✅ DataContext: auto-managed | Optimistic Locking: Handle `OptimisticLockException` on save, reload and retry, `@Version` field required | Error Handling: `OptimisticLockException`, `ConstraintViolationException`, `EntityAccessException`, `NoResultException` (use `.optional()`) | **Entity Events & Caching**: Entity Event Listeners: React to entity lifecycle events | Use `@EventListener` on service methods | Event Types: `BeforeEntityChangedEvent<T>`, `EntityChangedEvent<T>`, `BeforeEntityDeletedEvent<T>`, `EntityDeletedEvent<T>` | JPA Entity Callbacks (alternative): `@PrePersist`, `@PostPersist`, `@PreUpdate`, `@PostUpdate`, `@PostLoad`, `@PreRemove`, `@PostRemove` | Note: Entity events work with DataManager. JPA callbacks work with EntityManager but may bypass Jmix features | Entity Cache: Second-level cache for entities | Configured via `jmix.core.entity-cache.*` properties | Query Cache: Cache query results | Use `cacheable(true)` on queries | Cache Invalidation: Automatic on entity save/delete | Manual: `entityCache.evict(entityClass, id)` | Best Practices: Use query cache for frequently accessed, rarely changed data | Use entity cache for read-heavy entities | **Repositories & JDBC**: JmixDataRepository: Extend for custom repository methods | Combines Spring Data with Jmix features | Features: Spring Data query methods, Custom JPQL queries via @Query, Jmix security and FetchPlan support | Note: Prefer DataManager for most operations. Use repositories for custom query methods | JdbcTemplate: Use for complex SQL, batch operations, stored procedures | ✅ Complex SQL that JPQL can't handle | ✅ Batch operations (performance) | ✅ Stored procedures | ✅ ALWAYS parameterize queries (prevent SQL injection) | ⚠️ Bypasses Jmix security, audit, dynamic attributes | ⚠️ Returns raw data, not entities | **JPQL & LoadContext**: Jmix JPQL Extensions: Additional functions for JPQL queries | Date/Time: `DATE_TRUNC('day', e.createdDate)`, `DATEADD('day', 7, e.createdDate)`, `DATEDIFF('day', e.startDate, e.endDate)` | String: `CONCAT()`, `LOWER()`, `UPPER()`, `SUBSTRING()` | Aggregate: `COUNT()`, `SUM()`, `AVG()`, `MIN()`, `MAX()` | LoadContext: Programmatic data loading | Used by loaders internally | Can be used directly in services/views | Note: Prefer DataManager fluent API for most cases. LoadContext useful for complex scenarios or when reusing query definitions | **JPA (EclipseLink)**: Entity states: New (transient) → Managed (tracked) → Detached (context closed) → Removed | ❌ `new Entity()` = detached | ✅ `dataManager.create()` = managed | Relationships: @OneToMany: `mappedBy`, `cascade`, `orphanRemoval`, default LAZY | @ManyToOne: `fetch=LAZY`, explicit `@JoinColumn(name)` | @ManyToMany: `@JoinTable` with explicit columns | @OneToOne: `fetch=LAZY` | Cascade: ALL (composition only), PERSIST, MERGE, REMOVE | Best practice: Always LAZY, load via FetchPlan | Annotations: @Version: Required for optimistic locking, catch `OptimisticLockException` | @Entity/@Table: Specify `name`, indexes | @Column: Always specify `name`, `nullable`, `length` | @Embedded/@Embeddable: Value objects | @Enumerated: Prefer STRING | Callbacks: @PrePersist, @PreUpdate, @PostLoad | Detached: FetchPlan within tx, @Transactional in service, DTOs, reattach via `dataManager.save()` | **Configuration & Performance**: Configuration Properties: Control DataManager behavior via `application.properties` | Key Properties: `jmix.data.number-id-cache-size`, `jmix.data.default-fetch-plan`, `jmix.data.entity-cache.enabled`, `jmix.data.entity-cache.max-size`, `jmix.data.query-cache.enabled` | Store-Specific: `{storeName}.datasource.*`, `{storeName}.liquibase.change-log` | Performance: ✅ Use FetchPlan to avoid N+1 queries | ✅ Use query cache for frequently accessed data | ✅ Use batch operations (`saveAll`, `removeAll`) for multiple entities | ✅ Use `readOnly = true` for query transactions | ✅ Use partial FetchPlan for read-only operations | ✅ Index foreign keys and frequently queried columns | ⚠️ Avoid loading large collections without pagination | ⚠️ Use lazy loading by default, eager only when needed

## VIEWS
**Architecture**: StandardView (general) | StandardListView<T> (lists) | StandardDetailView<T> (detail/edit) | Constructor: services | @ViewComponent: UI components | ❌ @Autowired fields | **Annotations & Services**: Annotations: @ViewController (marks view class) | @ViewDescriptor (XML layout path) | @LookupComponent (component for lookup dialogs) | @EditedEntityContainer (data container for detail views) | @DialogMode (dialog size) | @ViewComponent (inject UI components) | @Install (customize component behavior) | Services: Messages (`messages.getMessage("key")` for i18n) | MessageBundle (view-specific messages) | UiComponents (factory for components) | ViewNavigators (programmatic navigation) | Notifications (user notifications) | EntityStates (check entity state: isNew, isDetached) | **Declarative UI (XML)**: Data Containers: InstanceContainer (single entity) | CollectionContainer (collection of entities) | Defined in `<data>` section | Binding: `dataContainer="containerId"` (bind container to component) | `property="fieldName"` (bind field to component) | `dataLoader="loaderId"` (bind loader to component) | Data Loaders: InstanceLoader (single entity) | CollectionLoader (collection) | Defined inside `<instance>` or `<collection>` | Attributes: `id` (required for collection), `readOnly="true"`, `dataContext="contextId"` | Programmatic: `@ViewComponent CollectionLoader<Order> ordersDl;` | `ordersDl.load()` | `ordersDl.setParameter("status", OrderStatus.PENDING); ordersDl.load()` | Actions: Types: `list_create`, `list_edit`, `list_remove`, `detail_saveClose`, `detail_close`, `lookup_select`, `lookup_discard` | Binding: `action="actionId"` | Custom: `@Subscribe("customButton")` | Facets: dataLoadCoordinator (auto-loading `auto="true"`) | urlQueryParameters (URL sync: filter, pagination) | FetchPlan: System FetchPlans: `_base` (default), `_instance_name` (includes @InstanceName), `_local` (direct attributes only) | Use `extends` to reference | **DataContext & Aggregates**: DataContext: StandardDetailView auto-creates/manages | Tracks entity changes | Save operation saves all "dirty" entities | Methods: `save()` (saves all dirty) | `clear()` (clears all) | `hasChanges()` (check changes) | `get(entity)` (get from context) | `remove(entity)` (mark for deletion) | Hierarchy (Aggregates): Parent-Child contexts for @Composition | Child saves to parent, parent saves to DB | Best Practices: ✅ StandardDetailView manages automatically | ✅ Use hierarchy for aggregates | ✅ Check `hasChanges()` before closing | ⚠️ View-scoped (not shared) | Editing Aggregates: @Composition marks composition relationship | Cascade delete | Saved together in one transaction | Flow: Parent View creates parent DataContext, loads aggregate with FetchPlan | Child View creates child DataContext, sets parent | Save in child → parent context | Save in parent → DB in one transaction | Best Practices: ✅ Always load aggregates with FetchPlan | ✅ Use StandardDetailView | ✅ Save only in root entity view | ⚠️ Don't save child entities separately | **Lifecycle & Events**: View Events: InitEvent (view initialization) | BeforeShowEvent (before shown, UI ready, URL params) | AfterShowEvent (after shown) | ReadyEvent (all components initialized) | Component Events: @Subscribe("componentId") (subscribe by ID) | Button Click: `@Subscribe("saveButton")` | Field Change: `@Subscribe("nameField")` | Grid Selection: `@Subscribe("usersDataGrid")` | Multiple: `@Subscribe({"button1", "button2"})` | Best Practices: ✅ Use InitEvent for data loading | ✅ Use BeforeShowEvent for URL params | ✅ Keep handlers focused | ⚠️ Avoid heavy operations (use async) | **Lookup Dialogs**: Setup: @LookupComponent (mark component) | Lookup Actions: `lookup_select`, `lookup_discard` in XML | Mode: Auto-switches when opened as dialog | Opening: ViewNavigators (programmatic) | LookupScreenFacet (builder) | API: `getSingleSelectedItem()` (single selection) | `getSelectedItems()` (multi-selection) | Best Practices: ✅ Handle selection in `AfterCloseEvent` | ✅ Use `StandardOutcome.SELECT` to check selection | ⚠️ Lookup mode is automatic

## SECURITY
**Entity Security**: @SystemLevel for system entities (User, Role) | @Secret for password fields | DataManager enforces row-level security | JmixUserDetails for authentication | **Roles**: Resource Roles (@ResourceRole): ✅ Define roles as interfaces with @ResourceRole | ✅ Use @EntityPolicy for CRUD | ✅ Use @EntityAttributePolicy for attributes | ✅ Use @ViewPolicy for screens | ✅ Use @MenuPolicy for menu | ✅ Use @SpecificPolicy for custom | ✅ SecurityScope.UI for UI-only roles | Row-Level Roles (@RowLevelRole): ✅ Use @RowLevelRole for instance-level restrictions | ✅ Use @PredicateRowLevelPolicy with JPQL | ✅ Use @JpqlRowLevelPolicy for complex queries | **User Repository & Authentication**: User Repository: ✅ Extend AbstractDatabaseUserRepository<User> | ✅ Override initSystemUser() / initAnonymousUser() | ✅ Use @Primary @Component("userRepository") | ✅ Set authorities via getGrantedAuthoritiesBuilder() | Authentication: ✅ Use `LoginViewSupport.authenticate(AuthDetails)` in login views | ✅ Use `CurrentAuthentication` to get current user | ✅ Use `AuthDetails.of(username, password).withLocale().withRememberMe()` | ✅ Handle: BadCredentialsException, DisabledException, LockedException, AccessDeniedException | **Authorization & User Management**: Authorization: ✅ Use `CurrentAuthentication.getUser()` / `isAuthenticated()` / `getAuthorities()` | ✅ DataManager enforces permissions automatically | ✅ Use `SystemAuthenticator` for system operations | User Management: ✅ User implements `JmixUserDetails` | ✅ Use `@Secret` for password | ✅ Use `@SystemLevel` for system entities | ✅ Implement: `isEnabled()`, `isAccountNonExpired()`, `isAccountNonLocked()`, `isCredentialsNonExpired()` | **Password Management**: ✅ Always use `PasswordEncoder.encode()` before saving | ✅ Never store plain text | ✅ Format: `{encoder}encodedPassword` (e.g., `{bcrypt}$2a$10...`, `{noop}plain` dev only) | ✅ Validate confirmation in UI | ✅ Use standard actions: `sec_changePassword`, `sec_resetPassword` | Formats: `{bcrypt}$2a$10...` (production), `{noop}plain` (dev only, NEVER production), `{pbkdf2}...` | Spring Security auto-detects prefix | **Security Configuration**: Security Filter Chain: ✅ Use @Order(JmixSecurityFilterChainOrder.CUSTOM) for custom endpoints | ✅ Define SecurityFilterChain beans in @Configuration | ✅ Use securityMatcher() for URL patterns | Role Authority Prefixes: ✅ Customize via `GrantedAuthorityDefaults` bean | ✅ Default: `ROLE_{roleCode}` (resource), `RL_{roleCode}` (row-level) | UI Component Policies (Optional Add-on): ✅ Use `@UiComponentPolicy` in resource roles | ✅ Requires `jmix-uiconstraints` add-on | ✅ Policies are "denying" - can only restrict | ✅ Applied after ReadyEvent | **Session & Testing**: Session Management: ✅ Use `SessionData` for session-scoped data | ✅ Use `UserSessions` (Audit add-on) for active sessions | ✅ Remember Me: `AuthDetails.withRememberMe(true)` | Security Testing: ✅ Use `@ExtendWith(AuthenticatedAsAdmin.class)` for system auth | ✅ Use `SystemAuthenticator.begin(username)` / `end()` manually | ✅ Test via DataManager operations (access denied exceptions) | External Authentication (Optional): ✅ OIDC add-on for OpenID Connect | ✅ LDAP add-on for LDAP/Active Directory | ✅ External IAM manages users/roles | ✅ Application maps external to internal roles | **Security Services**: SystemAuthenticator: ✅ Use `begin(username)` / `end()` in finally block | ✅ Use in background tasks, scheduled jobs, tests | CurrentUserSubstitution: ✅ Use `setSubstitutedUser(username)` / `clearSubstitution()` | ✅ Requires proper permissions | ✅ Use for support/debugging | Runtime/Database Roles: ✅ Defined at runtime, stored in SEC_ROLE table | ✅ Use SEC_ROLE_ASSIGNMENT for user-role assignments | ✅ UI available for management

## COMPLIANCE & DATA PROTECTION
**GDPR**: ✅ PII masking in logs (use `@Secret` or custom masking) | ✅ Right to deletion: Soft delete with @DeletedDate, hard delete via service | ✅ Data export: Implement data export endpoints (JSON/CSV) | ✅ Consent management: Track user consent (entity with consent fields) | ✅ Data minimization: Collect only necessary data | ✅ Retention policies: Configure data retention and archival | **Audit Logging**: ✅ Use `com.digtp.start.audit` logger for business events | ✅ Log: Entity CRUD, authentication, security changes, critical operations | ✅ Retention: Configure log retention policy (immutable audit logs) | ✅ Compliance: Store audit logs separately (immutable storage) | ✅ Correlation: Include `requestId`, `userId`, `entityId` in audit logs | ✅ Masking: Mask PII in audit logs (passwords, tokens, sensitive data) | **Rate Limiting**: ✅ Use Spring Security rate limiting (`RateLimiter`) | ✅ API rate limits: Per-user, per-endpoint | ✅ UI rate limits: Prevent abuse (login attempts, form submissions) | ✅ Configuration: Configure limits per endpoint/operation | ✅ Response: Return 429 Too Many Requests with Retry-After header | **Security Best Practices**: ✅ Input validation at all layers (UI, service, entity) | ✅ Output encoding (XSS prevention - Vaadin auto-handles) | ✅ CSRF protection (Vaadin auto-handles) | ✅ Security headers: Configure in SecurityFilterChain (HSTS, CSP, X-Frame-Options) | ✅ SQL injection: Always use parameterized queries (DataManager, JdbcTemplate) | ✅ Authorization: Check permissions before operations | **Antipatterns**: ❌ Logging PII without masking | ❌ No audit trail for critical operations | ❌ No rate limiting (vulnerable to abuse) | ❌ Missing security headers | ❌ Hard-coded secrets in code

## ADD-ONS
**Reports**: Dependency: `io.jmix.reports:jmix-reports-starter` | Designer: Studio Report Designer | Formats: XLSX, DOCX, PDF, HTML, CSV | Patterns: Template bands → DataManager queries | Parameters → user input | Output types → download/inline | Best Practices: ✅ Use FetchPlan in queries | ✅ Pagination for large datasets | ✅ Cache heavy reports | ❌ N+1 queries in bands | **Email**: Dependency: `io.jmix.email:jmix-email-starter` | Config: `jmix.email.*` properties | API: `emailer.sendEmail(EmailInfo)` | Templates: Freemarker/Thymeleaf | Attachments: `EmailAttachment` | Best Practices: ✅ Async sending (`emailer.sendEmailAsync()`) | ✅ Templates for HTML | ✅ Queue for bulk | ❌ Blocking send in transactions | **BPM**: Dependency: `io.jmix.bpm:jmix-bpm-starter` | Engine: Flowable | Designer: Studio BPMN Designer | Patterns: User Tasks → Views | Service Tasks → Spring beans | Events → `@EventListener` | Best Practices: ✅ Short transactions | ✅ Async service tasks for long ops | ✅ Error boundary events | ❌ Heavy logic in expressions | **Notifications**: Dependency: `io.jmix.notifications:jmix-notifications-starter` | API: `notificationManager.create()` → `withRecipient()` → `withSubject()` → `send()` | Channels: In-app, Email | Best Practices: ✅ Batch notifications | ✅ User preferences | **Audit**: Dependency: `io.jmix.audit:jmix-audit-starter` | Auto: Entity changes tracked | API: `entityLog.getEntityLogs(entity)` | Config: Enable per-entity in Studio | **Maps**: Dependency: `io.jmix.maps:jmix-maps-starter` | Provider: Mapbox/OpenStreetMap | Components: `GeoMap`, `Canvas` | Data: `@Geometry` fields (Point, Polygon, LineString)

## ANTIPATTERNS
❌ new Entity() | ❌ @Autowired fields | ❌ @Transactional in views | ❌ Native SQL without params | ❌ Missing @Version | ❌ Missing @JmixGeneratedValue | ❌ Lazy collections outside transaction | ❌ N+1 queries (use FetchPlan) | ❌ `new Entity()`, unparameterized SQL, missing @Transactional, lazy outside tx, missing @Version, N+1 queries, EAGER on @OneToMany, CascadeType.ALL everywhere | ✅ DataManager, @Transactional (services), JPQL, FetchPlan, @Version, parameterized queries, LAZY, explicit @JoinColumn
