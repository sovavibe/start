---
alwaysApply: true
autoFix: false
version: "1.0.0"
---

# AI ASSISTANT RULES

## GENERAL PRINCIPLES

### Code Quality First
- ✅ Always produce production-ready code
- ✅ Follow all project rules and conventions
- ✅ Fix root causes, not symptoms
- ✅ Refactor instead of workarounds
- ✅ Senior+ Software Engineer level

### Autonomous Workflow
- ✅ Work end-to-end autonomously
- ✅ Use context7 MCP docs when needed
- ✅ Check compilation after changes
- ✅ Verify linter compliance before completion
- ✅ Test changes when possible

## CODE GENERATION RULES

### Spring Annotations
- ✅ Use `@Service` for business logic in `service` package
- ✅ Use `@Component` for utilities in `config` package
- ✅ Match annotation to package location and class purpose
- ❌ Never use `@Component` for classes named `*Service` in `service` package

### Jmix Best Practices
- See `jmix-best-practices.mdc` for complete Jmix patterns
- Key: `dataManager.create()` not `new Entity()`, `@JmixEntity` + `@JmixGeneratedValue`, `EntityStates.isNew()`, `DataManager` for CRUD, `@Transactional` in services only

### Lombok Usage
- ✅ Use `@Slf4j` instead of manual Logger
- ✅ Use `@RequiredArgsConstructor` for constructor injection
- ✅ Use `@Getter/@Setter` for entities
- ✅ Use `@FieldDefaults` for automatic final fields
- ✅ Use `@EqualsAndHashCode(onlyExplicitlyIncluded = true)` for entities
- ✅ Use `@ToString(onlyExplicitlyIncluded = true)` for entities

### Validation
- ✅ Use `@NonNull`/`@Nullable` annotations
- ✅ Validate at service layer, not just entity level
- ✅ Use Bean Validation (Jakarta Validation)
- ✅ Provide detailed error messages

## ERROR HANDLING

### Compilation Errors
- ✅ Fix immediately when detected
- ✅ Check imports and dependencies
- ✅ Verify annotation usage matches package location
- ✅ Test compilation after fixes

### Linter Errors
- ✅ Fix all linter errors before completion
- ✅ Run `make analyze-full` before commit (NOT `./gradlew codeQualityFull`)
- ✅ Minimize suppressions - fix root cause instead
- ✅ MANDATORY: Always document suppression reason with comment (see Suppression Documentation section)

### SonarLint Configuration
- ✅ Use standard plugin behavior (fails on all issues - best practice)
- ✅ Suppress issues properly: use `@SuppressWarnings("squid:RuleKey")` in code or `sonar-project.properties` for global rules
- ✅ Global suppressions: configure in `config/sonar-project.properties` using `sonar.issue.ignore.multicriteria`
- ❌ NEVER use `ignoreFailures=true` or manual XML parsing - fix or suppress properly
- ❌ NEVER ignore warnings globally - fix root cause or suppress in specific places

### Suppression Documentation (MANDATORY)
- ✅ ALWAYS document reason for suppression with comment
- ✅ Format: `@SuppressWarnings("squid:RuleKey") // Reason: explanation` or `// NOSONAR RuleKey - explanation`
- ✅ Examples:
  - `@SuppressWarnings("PMD.NcssCount") // Health check method needs comprehensive checks`
  - `// NOSONAR java:S110 - Framework pattern: Jmix views extend multiple framework classes`
- ❌ NEVER suppress without explanation - always include "why" comment

## DOCUMENTATION RULES - STRICT (TOKEN CONSERVATION)

### ❌ CRITICAL: NO AUTOMATIC DOCUMENTATION
- ❌ NEVER create documentation files (*.md) unless EXPLICITLY requested
- ❌ NEVER generate "helpful" documentation summaries
- ❌ NEVER create documentation "for future reference"
- ❌ NEVER create multiple documentation files for same topic
- ❌ NEVER create documentation as "completion report"
- ❌ NEVER create "plan" files - only create when implementing
- ❌ NEVER create duplicate files (check existing first)
- ❌ NEVER create "quick reference" if main guide exists
- ✅ ONLY create documentation when user EXPLICITLY asks: "create docs", "document this", "write README"
- ✅ ALWAYS check existing documentation before creating new
- ✅ ALWAYS update existing files instead of creating duplicates

### When to Create Documentation
- ✅ ONLY when user explicitly requests: "create documentation", "write docs", "document this"
- ✅ Place in `docs/` directory (not `.archive/`)
- ✅ Use clear, concise language
- ✅ Include code examples when helpful
- ❌ DO NOT create multiple files for same topic

### Documentation Structure
- ✅ `docs/quality/` - code quality guides (only if requested)
- ✅ `docs/` - general documentation (only if requested)
- ❌ NEVER place useful docs in `.archive/`
- ❌ NEVER create duplicate documentation files

### Token Conservation
- ❌ DO NOT generate long documentation files
- ❌ DO NOT create multiple files for same feature
- ❌ DO NOT write "completion summaries" as documentation
- ✅ Focus on code, not documentation
- ✅ If documentation needed, create ONE concise file

## WORKFLOW RULES

### Build Commands (MANDATORY)
- ✅ ALWAYS use `make` commands for all verification tasks
- ✅ NEVER run `./gradlew` directly for checks - use `make` instead
- ✅ Commands to use:
  - `make analyze` - code quality analysis (Checkstyle, PMD, SpotBugs, SonarLint)
  - `make analyze-full` - full analysis including CSS/YAML linting
  - `make test` - run tests
  - `make format-check` - check code formatting
  - `make format` - format code
  - `make ci` - full CI pipeline
- ✅ Use `make analyze-full NO_CCACHE=1` if configuration cache issues occur
- ❌ NEVER run `./gradlew codeQualityFull` directly - use `make analyze-full`
- ❌ NEVER run `./gradlew test` directly - use `make test`

### Development Process
1. ✅ Understand requirements fully
2. ✅ Search codebase for existing patterns
3. ✅ Implement changes following project rules
4. ✅ Compile and verify
5. ✅ Check linters (at end of work) - via `make analyze-full`
6. ✅ Test if possible - via `make test`

### Before Completion
- ✅ All code compiles successfully
- ✅ All linter checks pass (or documented suppressions) - verified via `make analyze-full`
- ✅ Code follows project conventions
- ✅ No workarounds or hacks
- ✅ Production-ready quality

## SECURITY RULES

### Secrets & Credentials
- ❌ NEVER hardcode passwords, tokens, or secrets
- ✅ Use environment variables via `@Value("${key}")`
- ✅ Use configuration profiles for different environments
- ❌ NEVER log passwords or tokens

### Input Validation
- ✅ Always validate user input
- ✅ Use parameterized queries (JPQL)
- ✅ Sanitize data before processing
- ✅ Use Bean Validation annotations

## LOGGING RULES

### Structured Logging
- ✅ Use structured format: `log.info("key={}", value)`
- ✅ Use appropriate log levels (DEBUG/INFO/WARN/ERROR)
- ✅ Include context (requestId, userId via MDC)
- ❌ NEVER concatenate strings in logs
- ❌ NEVER log passwords or tokens

### Audit Logging
- ✅ Log all security events (login, logout, access denied)
- ✅ Log all data changes (create, update, delete)
- ✅ Use separate audit logger
- ✅ Include all relevant context

## TESTING RULES

### Test Quality
- ✅ NEVER delete failing tests → fix root cause
- ✅ Use Testcontainers for integration tests
- ✅ Use `@Transactional` rollback for test isolation
- ✅ Test critical business logic

## COMMUNICATION RULES

### Language
- ✅ Code: English
- ✅ Documentation: English
- ✅ Chat: Russian (if user prefers)
- ✅ Comments: English

### Brevity
- ✅ Keep responses concise (1-2 sentences when possible)
- ✅ Focus on implementation, not explanations
- ✅ No unnecessary reports or summaries

## PROHIBITIONS

### Code Quality
- ❌ NO workarounds or hacks
- ❌ NO `@SuppressWarnings` without justification
- ❌ NO linter suppressions in config files
- ❌ NO dead code
- ❌ NO `System.out.println` → use SLF4J

### Architecture
- ❌ NO `@Autowired` fields → use constructor injection (EXCEPT tests: `@Autowired` allowed in test classes)
- ❌ NO `new Entity()` → use `dataManager.create()`
- ❌ NO hardcoded values → use configuration
- ❌ NO `System.getenv()` → use `@Value`

### Security
- ❌ NO secrets in code
- ❌ NO passwords in logs
- ❌ NO hardcoded credentials

## CONTEXT AWARENESS

### Codebase Understanding
- ✅ Search codebase before implementing
- ✅ Follow existing patterns
- ✅ Use existing utilities and services
- ✅ Maintain consistency with project style

### Framework Knowledge
- ✅ Use context7 MCP docs for framework questions
- ✅ Follow Jmix best practices
- ✅ Follow Vaadin best practices
- ✅ Follow Spring Boot best practices

## QUALITY METRICS

### File Size
- ✅ Maximum 250 lines per file
- ✅ Refactor if exceeded

### Complexity
- ✅ Maximum 10 cyclomatic complexity
- ✅ Maximum 10 cognitive complexity
- ✅ Refactor if exceeded

### Code Standards
- ✅ SOLID principles
- ✅ Clean Architecture
- ✅ DRY + KISS
- ✅ Immutable where possible
