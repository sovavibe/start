---
alwaysApply: true
autoFix: false
version: "2.0.0"
---

# AI ASSISTANT RULES

## PRINCIPLES
Production-ready code | Senior+ level | Fix root causes, not symptoms | Refactor, not workarounds | Autonomous end-to-end | Use context7 MCP docs | Check compilation | Verify linters via `make analyze-full`

**Vibe Coding**: Minimal suppressions, maximum code quality | **Token Economy**: Optimize rule usage | See `@suppress-policy.mdc` for suppression guidelines

## RULE SELECTION & TOKEN ECONOMY
**CRITICAL**: When choosing which rules to apply, prioritize token efficiency and applicability:
- **Applicability First**: Only apply rules relevant to current task/context | Skip irrelevant rules even if they exist
- **Token Efficiency**: Reference rules by name (`@rule-name.mdc`) instead of copying content | Use `@rules.mdc` for quick lookup
- **Rule Logic**: Understand WHY rules exist before applying | Don't blindly follow rules that don't fit the context
- **Selective Application**: 
  - ✅ Apply `@jmix-best-practices.mdc` when working with Jmix entities/views
  - ✅ Apply `@logging-policy.mdc` when working with logging
  - ❌ Don't load all rules for simple tasks
  - ❌ Don't copy entire rule content into context
- **Examples**:
  - Simple fix: Reference `@rules.mdc` → find relevant section → apply
  - Complex task: Load specific rule file (`@jmix-data-access.mdc`) → apply relevant parts
  - Don't: Load 10 rule files for a 5-line change

## CODE GENERATION
**Spring**: @Service in service/, @Component in config/ | **Jmix**: See `@jmix-best-practices.mdc` | **Lombok**: @Slf4j, @RequiredArgsConstructor, @Getter/@Setter, @FieldDefaults, @EqualsAndHashCode(onlyExplicitlyIncluded=true) | **Validation**: @NonNull/@Nullable, service layer, Bean Validation | **Copyright**: Apache License 2.0, Digital Technologies and Platforms LLC | `./gradlew format` auto-adds copyright headers

**Imports**: ❌ NEVER use FQN (Fully Qualified Names) in code | ✅ ALWAYS use imports | **Exception**: FQN allowed only for name conflicts (e.g., `com.github.benmanes.caffeine.cache.Cache` vs `org.springframework.cache.Cache`) | Example: `org.springframework.cache.Cache cache` → `import org.springframework.cache.Cache; Cache cache` | See `@code-quality.mdc` FQN section

## ERRORS
**Compilation**: Fix immediately, check imports, verify annotations | **Linters**: Fix all before completion, use `make analyze-full` | **Suppressions**: See `@suppress-policy.mdc` for comprehensive guidelines | **Quick decision**: See `@ai-false-positives.mdc` for false positives

## DOCUMENTATION (STRICT)
❌ Create docs unless EXPLICITLY requested | ❌ Summaries, "for reference", completion reports, plans, duplicates | ✅ Only when user asks: "create docs", "document this", "write README" | ✅ Check existing first, update instead of duplicate | ✅ Place in `docs/` (not `.archive/`) | ✅ ONE concise file if needed | Focus on code, not docs

## WORKFLOW
**Commands**: `make analyze-full` (not `./gradlew codeQualityFull`), `make test`, `./gradlew format` (Palantir Baseline) | **Process**: Understand → Search codebase → Implement → Compile → Linters (end) → Test | **Before completion**: Compiles, linters pass, follows conventions, production-ready

**ITERATION COMPLETION CHECKLIST** (MANDATORY):
1. ✅ Code compiles without errors
2. ✅ Run `make analyze-full` - all linters must pass (Checkstyle, PMD, SpotBugs, SonarLint)
3. ✅ Fix all linter violations before marking task complete
4. ✅ Code follows project conventions and standards
5. ✅ Production-ready quality (no workarounds, proper error handling)
6. ✅ All tests pass (if applicable)

**Formatting**: Use `./gradlew format` (Palantir Baseline format task) or `./gradlew spotlessApply` (Spotless only). Palantir Baseline automatically configures Spotless with import order, unused imports removal, and other formatting rules.

## CI/CD BEST PRACTICES
**GitHub Actions**: Use latest stable versions, pin major versions (v5, v6), enable caching | **Parallelization**: Split jobs (format-check, code-quality, test, build) for faster execution | **Timeouts**: Set timeouts for all jobs (10-30 min) | **Dependabot**: Group updates, limit PRs, monthly schedule, auto-merge safe updates | **Security**: Use GITHUB_TOKEN, scan dependencies (Trivy, OWASP), upload SARIF reports | **Commitlint**: Enforced via GitHub Actions (see `@conventional-commits.mdc`) | **Branch naming**: Enforced via GitHub Actions (see `@branch-naming.mdc`) | **PR creation**: Use `./scripts/create-pr.sh` for auto-generated descriptions

## CONTEXT
Search codebase first | Follow existing patterns | Use context7 MCP docs | Maintain consistency | See `@context-management.mdc` for details | See `@rules.mdc` for security, logging, testing, prohibitions, metrics

## GIT WORKFLOW
**Branches**: See `@branch-naming.mdc` for naming conventions | **Commits**: See `@conventional-commits.mdc` for format | **PRs**: See `@github.mdc` for workflow | **Auto PR**: Use `./scripts/create-pr.sh` to create PR with auto-generated description from diff

## COMMUNICATION LANGUAGE
**CRITICAL**: Language usage is strict and context-dependent:
- **Code & Documentation**: ALWAYS English (comments, JavaDoc, README, code, commit messages, rules documentation)
- **Chat with User**: ✅ Use Russian when user communicates in Russian | ✅ Use English when user communicates in English | Adapt to user's language preference
- **Brevity**: Be concise, avoid verbose explanations unless requested
- **Examples**: 
  - ✅ Chat in Russian: "Файлы успешно добавлены в git"
  - ✅ Code comment: `// Loads user from database` (always English)
  - ✅ Rule documentation: "Use DataManager.create() instead of new Entity()" (always English)
  - ❌ Code comment in Russian: `// Загружает пользователя из базы данных`
