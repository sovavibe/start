---
globs: ["**/service/**/*.java", "**/repository/**/*.java", "**/entity/**/*.java"]
autoFix: true
version: "9.0.0"
---

# DATABASE - JPA (EclipseLink via Jmix)

Jmix uses EclipseLink as JPA. See rules.mdc and jmix-best-practices.mdc for DataManager basics.

## PERSISTENCE CONTEXT
Entity states: New (transient) → Managed (tracked) → Detached (context closed) → Removed | ❌ `new Entity()` = detached | ✅ `dataManager.create()` = managed

## QUERIES & TRANSACTIONS
**JPQL** preferred, native SQL only when needed | **FetchPlan**: `fetchPlans.builder(Order.class).add("customer").build()` - avoid N+1 | **@Transactional**: Services only, `readOnly=true` for queries | **Propagation**: REQUIRED (default), REQUIRES_NEW, MANDATORY

## RELATIONSHIPS
**@OneToMany**: `mappedBy`, `cascade`, `orphanRemoval`, default LAZY | **@ManyToOne**: `fetch=LAZY`, explicit `@JoinColumn(name)` | **@ManyToMany**: `@JoinTable` with explicit columns | **@OneToOne**: `fetch=LAZY` | **Cascade**: ALL (composition only), PERSIST, MERGE, REMOVE | **Best practice**: Always LAZY, load via FetchPlan

## ANNOTATIONS & VALIDATION
**@Version**: Required for optimistic locking, catch `OptimisticLockException` | **@Entity/@Table**: Specify `name`, indexes | **@Column**: Always specify `name`, `nullable`, `length` | **@Embedded/@Embeddable**: Value objects | **@Enumerated**: Prefer STRING | **Callbacks**: @PrePersist, @PreUpdate, @PostLoad | **Validation**: Bean Validation (@NotNull, @Size) at entity level, business validation in service

## DETACHED & INHERITANCE
**Detached**: FetchPlan within tx, @Transactional in service, DTOs, reattach via `dataManager.save()` | **Inheritance**: Prefer composition, use `@Embedded` for value objects

## ANTIPATTERNS
❌ `new Entity()`, unparameterized SQL, missing @Transactional, lazy outside tx, missing @Version, N+1 queries, EAGER on @OneToMany, CascadeType.ALL everywhere | ✅ DataManager, @Transactional (services), JPQL, FetchPlan, @Version, parameterized queries, LAZY, explicit @JoinColumn
