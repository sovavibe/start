---
globs: ["**/service/**/*.java", "**/async/**/*.java", "**/*Async*.java", "**/*Task*.java"]
autoFix: true
version: "1.0.0"
---

# ASYNC PATTERNS (Java 21)

## VIRTUAL THREADS
**Java 21**: Prefer virtual threads over platform threads | **Spring Boot 3.2+**: `spring.threads.virtual.enabled=true` | **Tomcat**: Auto-uses virtual threads for requests

### Usage
```java
// Simple task
Thread.startVirtualThread(() -> processTask());

// ExecutorService
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    executor.submit(() -> processTask());
}
```

### When to Use
✅ I/O-bound operations (DB, HTTP, file) | ✅ High-concurrency scenarios | ❌ CPU-bound tasks (use platform threads) | ❌ Long-running tasks with thread-locals

## COMPLETABLEFUTURE
**Async composition**: Chain operations | **Error handling**: `exceptionally()`, `handle()` | **Combine**: `thenCombine()`, `allOf()`, `anyOf()`

### Patterns
```java
CompletableFuture.supplyAsync(() -> fetchData())
    .thenApply(data -> transform(data))
    .exceptionally(ex -> handleError(ex));
```

## SPRING @ASYNC
**Setup**: `@EnableAsync` + `@Async` on method | **Return**: `void`, `Future<T>`, `CompletableFuture<T>` | **Executor**: Configure `TaskExecutor` bean

### Jmix Integration
⚠️ **Security context**: Not propagated by default | ⚠️ **DataManager**: Use `UnconstrainedDataManager` in async or propagate context | ✅ **Events**: Use `@TransactionalEventListener(phase = AFTER_COMMIT)`

## ANTIPATTERNS
❌ `Thread.sleep()` in virtual threads → use `TimeUnit.sleep()` | ❌ Blocking in `CompletableFuture.supplyAsync()` without executor | ❌ `synchronized` with virtual threads (pins carrier) → use `ReentrantLock` | ❌ Missing error handling in async chains

## TESTING
Use `Awaitility.await().atMost(5, SECONDS).until(() -> condition)` | Mock async calls with `CompletableFuture.completedFuture()`
