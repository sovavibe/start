---
alwaysApply: true
version: "10.0.0"
---

# CORE RULES

## PROJECT STANDARDS
**Tech Stack**: Java 21 (virtual threads, pattern matching, records) | Jmix 2.7.1 | Vaadin FlowUI 24+ | Spring Boot 3.x | EclipseLink | Liquibase | Gradle 8.12.x (max 8.x, incompatible with 9+) | PostgreSQL | Quality: Palantir Baseline (Checkstyle, PMD, SpotBugs, Spotless, Error-prone), SonarLint | Frontend: stylelint, prettier | **Principles**: Production-ready code | Senior+ level | Fix root causes, not symptoms | Refactor, not workarounds | SOLID, Clean Architecture, DRY, KISS | Final fields, immutable, constructor injection, validation | Simpler is better | ❌ Utilities for single use | ✅ Existing libraries | ✅ Direct calls over abstractions | ✅ Centralize only mass patterns (3+) | **Architecture Principles**: Clean Architecture: ✅ Layers: Presentation (Views) → Business (Services) → Infrastructure (DataManager, Repositories) | ✅ Dependency Rule: Inner layers don't depend on outer | ✅ Use cases: Business logic in services | ✅ Entities: Domain models, not DTOs | Extensibility: ✅ Plugin pattern: Use Spring @ConditionalOnProperty | ✅ Strategy pattern: For interchangeable algorithms | ✅ Factory pattern: For complex object creation | ✅ Event-driven: Use Spring Events for loose coupling | **Onboarding & Quick Start**: Setup: See `docs/getting-started/SETUP.md` | Quick start: `make setup && make postgres-up && make run` | Access: http://localhost:8080 (admin/admin) | Common Pitfalls: ❌ Java version != 21 → Use Java 21 | ❌ Docker not running → Start Docker | ❌ Port 8080 in use → Change `SERVER_PORT` | ❌ Database connection fails → Check `make postgres-up` | IDE Setup: IntelliJ: Import Gradle project, Java 21 SDK, enable annotation processing | VS Code: Install Java Extension Pack, SonarLint, Checkstyle

## METRICS & QUALITY
**Limits**: 250 lines/file, 10 cyclomatic, 10 cognitive complexity | **Refactor** if exceeded: extract methods, split files | **Formatting**: 120 chars/line (Palantir Style Guide standard), Palantir Java Format (Spotless via Baseline) | **Standards**: SOLID, Clean Architecture, DRY, KISS | Final fields, immutable | Constructor injection | @Nullable/@NonNull | Validation: @Email, @NotNull, @Size | Senior+ level: production-ready, maintainable, testable | **Spring & Env**: @Configuration, @Bean | @Transactional (service, readOnly) | ❌ System.getenv() → ✅ @Value("${app.key:default}") | Profiles: application-{profile}.yml | ❌ Secrets in code → env vars

## AI ASSISTANT BEHAVIOR
**Principles**: Production-ready code | Senior+ level | Fix root causes, not symptoms | Refactor, not workarounds | Autonomous end-to-end | Use context7 MCP docs | Check compilation | Verify linters via `make analyze-full` | **Vibe Coding**: Minimal suppressions, maximum code quality | **Token Economy**: Optimize rule usage | **Simplicity**: Simpler is better | **Rule Selection**: Prioritize token efficiency and applicability | Applicability First: Only apply rules relevant to current task/context | Token Efficiency: Reference rules by name (`@rule-name.mdc`) instead of copying | Rule Logic: Understand WHY before applying | Selective Application: ✅ Apply `@jmix.mdc` for Jmix entities/views/data access | ✅ Apply `@patterns.mdc` for error handling/async/API | ❌ Don't load all rules for simple tasks | ❌ Don't copy entire rule content

## CODE GENERATION
**Spring**: @Service in service/, @Component in config/ | **Jmix**: See `@jmix.mdc` | **Lombok**: @Slf4j, @RequiredArgsConstructor, @Getter/@Setter, @FieldDefaults, @EqualsAndHashCode(onlyExplicitlyIncluded=true) | **Validation**: @NonNull/@Nullable, service layer, Bean Validation | **Copyright**: Apache License 2.0, Digital Technologies and Platforms LLC | **Imports**: ❌ FQN in code | ✅ Use imports | **Exception**: FQN only for name conflicts | **FQN Check**: Rule enforced via AI rules and code review, not by Checkstyle

## WORKFLOW & COMMANDS
**Commands**: `make analyze-full` (not `./gradlew codeQualityFull`), `make test`, `./gradlew format` | **Process**: Understand → Search codebase → Implement → Compile → Linters (end) → Test | **Before completion**: Compiles, linters pass, follows conventions, production-ready | **ITERATION COMPLETION CHECKLIST** (MANDATORY): 1) ✅ Code compiles without errors | 2) ✅ Run `make analyze-full` - all linters pass (Checkstyle, PMD, SpotBugs, SonarLint) | 3) ✅ Fix all linter violations before marking task complete | 4) ✅ Code follows project conventions and standards | 5) ✅ Production-ready quality (no workarounds, proper error handling) | 6) ✅ All tests pass (if applicable) | 7) ✅ **Cleanup**: Remove temporary files, symlinks, test artifacts, legacy code, unused imports, commented-out code, debug statements | Delete files created during exploration | Remove workarounds replaced by proper solutions | Clean up after refactoring

## ERRORS & DOCUMENTATION
**Compilation**: Fix immediately, check imports, verify annotations | **Linters**: Fix all before completion, use `make analyze-full` | **Suppressions**: See `@quality.mdc` | **Quick decision**: See `@quality.mdc` → QUICK DECISION TREE | **Documentation (STRICT)**: ❌ Create docs unless EXPLICITLY requested | ❌ Summaries, "for reference", completion reports, plans, duplicates | ✅ Only when user asks: "create docs", "document this", "write README" | ✅ Check existing first, update instead of duplicate | ✅ Place in `docs/` (not `.archive/`) | ✅ ONE concise file if needed | Focus on code, not docs

## CONTEXT MANAGEMENT
**Principles**: Search codebase first before asking questions | Use context7 MCP docs for framework documentation | Maintain project context across sessions | Reference existing patterns and conventions | **Workflow**: 1) Understand: Search codebase for similar patterns | 2) Reference: Use rule files | 3) Document: Only when explicitly requested | 4) Consistency: Follow existing code style and architecture | **Tools**: Context7 MCP: For Jmix, Spring, Vaadin documentation | Codebase search: Semantic search for patterns | Rule files: Quick reference via `@filename.mdc` syntax | **Patterns**: Before asking: Search codebase for similar implementations | Framework docs: Use context7 MCP instead of external docs | Rule lookup: Reference rules for project standards | Code style: Follow existing patterns in codebase | **Large Codebase Optimization**: Scoped search: Use semantic search with specific directories/packages | Incremental context: Load only relevant rules via `@filename.mdc` references | File references: Use `@filepath` to include specific files instead of entire directories | Pattern matching: Search for patterns before asking questions | Rule selection: Apply only relevant rules

## CONVENTIONAL COMMITS
**Format**: `<type>[scope]: <description>` | Optional body | Optional footer(s) | **Types**: feat | fix | docs | style | refactor | perf | test | build | ci | chore | revert | **Scopes**: Framework & UI: jmix | vaadin | ui | frontend | Application: entity | view | service | api | Infrastructure: config | db | docker | kubernetes | k8s | helm | observability | Security: security | auth | Database: liquibase | migration | Quality: test | checkstyle | pmd | spotbugs | sonar | quality | format | lint | CI/CD: ci | github | workflow | Dependencies: deps | gradle | npm | node | Docs & Scripts: docs | scripts | makefile | husky | commitlint | Other: copyright | rules | cleanup | logging | metrics | monitoring | **Rules**: Imperative mood: "add" not "added"/"adds" | Lowercase, no period, max 72 chars (50 preferred) | Body: WHAT/WHY, wrap 72, bullets for multiple | Footer: `BREAKING CHANGE:`, `Closes #123`, `Fixes #456` | Breaking: `type!:` or footer `BREAKING CHANGE:` | **Prohibitions**: ❌ Past/present tense | Period at end | Vague | Multiple types | Uppercase type

## LOGGING POLICY
**Principles**: Observability First: Logs are the eyes of the system. Removing logs = loss of observability | Structured Logging: Always use parameterized messages, never concatenation | Context Matters: Always log important context (userId, entityId, operation, requestId) | Security: Never log passwords, tokens, secrets, PII (except audit.log with masking) | **Log Levels**: DEBUG: Detailed diagnostics, method tracing, internal states. Does NOT affect production (INFO level) | INFO: Business events (entity CRUD, successful operations), component start/stop, state changes | WARN: Issues that don't break functionality, validation failed (expected), retry operations, deprecated API | ERROR: Critical errors, exceptions, operations that cannot be executed, system errors | **Structured Logging**: ✅ Correct: `log.info("User created: id={}, username={}", user.getId(), user.getUsername())` | ❌ Incorrect: `log.info("User created: id=" + user.getId())` (concatenation) | ❌ Incorrect: `log.info("User created")` (no context) | **When NOT to Remove Logs**: CRITICAL: Do NOT remove logs for: 1) Configuration/initialization (config loading, component init, app start/stop, DB migrations) | 2) Error handling (catch blocks - always log exceptions, validation failed, retry operations) | 3) Business events (entity CRUD, authentication success/failure, critical operations) | 4) Diagnostics (DEBUG logs for internal states, execution tracing, call parameters) | Rule: If logging helps understand what's happening - do NOT remove it | **Security**: ❌ Never log: Passwords (plain/hashed), tokens (JWT, API keys, sessions), secrets, PII without masking (except audit.log), SQL with secret parameters | ✅ Safe: `log.info("User authenticated: username={}", username)` | ❌ Never: `log.info("User authenticated: password={}", password)` | **Context (MDC) & Audit**: MDC: Always use MDC for request context: `requestId` (UUID), `userId` (if authenticated), `sessionId` (optional) | Clear in `finally` block | Audit Logging: Use separate logger `com.digtp.start.audit` for business events (entity CRUD, authentication, critical operations, security changes) | **Performance & Antipatterns**: Performance: Log slow operations (>100ms services, >500ms views) at DEBUG level | Don't log in hot paths unnecessarily | Use `log.isDebugEnabled()` before expensive operations | Antipatterns: ❌ Removing logs for "cleanliness" → ✅ Keep logs | ❌ No context → ✅ Include context (id, username, operation) | ❌ Concatenation in loop → ✅ Use parameterized messages | **Checklist & Error Logging**: Checklist: Before removing/changing a log: Does it help understand the system? Used for diagnostics? Contains context (userId, entityId, operation)? Business event or error? **If yes → keep it** | Error Logging: CRITICAL: Always log exceptions in catch blocks with context | ✅ Include exception as last parameter | ✅ Include context (entityId, userId, operation) | ✅ ERROR for unexpected, WARN for expected | ❌ Never swallow silently | ❌ Never use `printStackTrace()` or `System.out.println()`

## TESTING POLICY
**Principles**: NEVER DELETE FAILING TESTS! Fix the reason, not the test | Simplicity First: Simpler is better | ❌ Don't create utilities for single use | ✅ Use existing libraries (TestFixtures, UiTestUtils) | ✅ Direct method calls instead of reflection | ✅ Cast View to concrete type instead of reflection | **When Fails**: ✅ Investigate → Root cause → ASK USER if external dependency → FIX → Run | ❌ Delete | @Disabled | Comment out | Common Failures: TestContainers: Docker not running → Ask user start Docker | NEVER delete integration tests | Missing Dependencies: Implement or wait | Exceptions for Deletion: User requests | Duplicate | Removed feature | Better replacement | If all NO → DON'T DELETE | **Test Types**: Unit Tests: Annotations: `@Test` only | Pattern: No Spring context, mock dependencies | Use: Pure logic, calculations, validators | Integration Tests: Annotations: `@SpringBootTest` + `@ExtendWith({SpringExtension.class, AuthenticatedAsAdmin.class})` | Pattern: Full Spring context, `@Autowired` fields allowed | Use: Service layer, DataManager, security, transactions | Cleanup: `@AfterEach` with `dataManager.remove()` | UI Integration Tests: Annotations: `@UiTest` + `@SpringBootTest(classes = {Application.class, FlowuiTestAssistConfiguration.class})` | Dependencies: `io.jmix.flowui:jmix-flowui-test-assist` | Pattern: `UiTestUtils.getCurrentView()`, `UiTestUtils.getComponent(view, "id")`, `button.click()`, `field.setValue()` | Use: View navigation, form interactions, DataGrid | Helper: Use `getCurrentViewAsView()` from `AbstractIntegrationTest` instead of `(View<?>) UiTestUtils.getCurrentView()` | E2E Tests (Optional): Dependencies: `io.jmix.masquerade:masquerade-core`, `masquerade-app` | Pattern: Page Object, Selenium/Selenide | Use: Full workflows, browser interactions | Note: Slower, use sparingly | **Spring Boot + Jmix Patterns**: Annotations: Unit: `@Test` only | Integration: `@SpringBootTest` + `@ExtendWith({SpringExtension.class, AuthenticatedAsAdmin.class})` | UI: `@UiTest` + `@SpringBootTest(classes = {Application.class, FlowuiTestAssistConfiguration.class})` | @Autowired fields allowed in tests (Spring Boot standard) | Jmix Extensions: `@ExtendWith({SpringExtension.class, AuthenticatedAsAdmin.class})` - SpringExtension first (init context), AuthenticatedAsAdmin second (admin security) | AuthenticatedAsAdmin auto-sets admin user, cleans up after | Test Structure (AAA/GWT): REQUIRED: Every test MUST follow AAA (Arrange-Act-Assert) or GWT (Given-When-Then) with explicit comments: `// Arrange (Given)` (setup test data, mocks) | `// Act (When)` (execute code under test, single action) | `// Assert (Then)` (verify outcome, multiple assertions OK) | Rules: Clear section separation, one action in Act, multiple assertions OK | **Assertions & DataManager**: Assertions & Cleanup: AssertJ: `assertThat(actual).isEqualTo(expected)` (auto-available in Jmix) | Cleanup: `@AfterEach` with `dataManager.remove(entity)` or queries | Test Data: Unique identifiers (`"test-user-" + System.currentTimeMillis()`), cleanup patterns (`"test-%"`) | DataManager in Tests: ✅ `dataManager.create(Entity.class)` (create) | ✅ `dataManager.save(entity)` (save) | ✅ `dataManager.load(Entity.class).id(id).one()` (load by ID) | ✅ `dataManager.remove(entity)` (delete) | ✅ Queries for cleanup: `dataManager.load(Entity.class).query("e.field like ?1", "test-%").list()` | **Testcontainers**: Pattern: @Testcontainers abstract BaseIntegrationTest | @Container static PostgreSQLContainer withReuse(true) | @DynamicPropertySource configureProperties | @SpringBootTest @Transactional extends BaseIntegrationTest | Performance: testcontainers.reuse.enable=true (2-5s startup) | @Transactional rollback | Singleton container (NOT per test) | Antipatterns: New container per test → singleton | @DirtiesContext everywhere → slow | No reuse → slow

## SECURITY & PROHIBITIONS
**Security**: @Secret passwords | PasswordEncoder.encode() | Parameterized queries | **Prohibitions**: System.out.println → SLF4J | System.getenv() → @Value | @Autowired fields → constructor (tests: allowed) | Dead code → remove | Workarounds → refactor | @SuppressWarnings → document why

## COMMUNICATION LANGUAGE
**MANDATORY**: Code & docs: ASCII-only (comments, JavaDoc, README, code, commits, strings, errors, logs) | Chat: Use user's language | ❌ Non-ASCII in code/docs | ✅ ASCII-only always
